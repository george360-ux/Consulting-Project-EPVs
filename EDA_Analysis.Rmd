---
title: "EDA_Analysis"
author: "George Acostalemus, Chunlin Liu, Sile Wang"
date: "2025-10-31"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load In Packages

```{r}
library(readxl)
library(dplyr)
library(ggplot2)
library(boot)
library(patchwork)
library(lme4)
library(lmtest)
library(broom.mixed)
library(car)
library(MatchIt)
library(mgcv)
library(gamm4)
library(broom)
library(tidyverse)
library(itsadug)
library(purrr)
```

## Read In The DataSet

You can also embed plots, for example:

```{r}
# Read in the dataset
scattering <- read_excel("radii.xlsx", sheet = "scattering")
retardance <- read_excel("radii.xlsx", sheet = "retardance")
orientation <- read_excel("radii.xlsx", sheet = "orientation")


scattering$property <- "scattering"
retardance$property <- "retardance"
orientation$property <- "orientation"

main_data <- bind_rows(scattering, retardance, orientation)

# Clean variable names for plotting
main_data$Groups <- factor(main_data$Groups, levels = c("control", "experimental"))
main_data$Region <- factor(main_data$Region, levels = c("front", "occipital"))
```

**Counting**

```{r}
# Counts per group and region
main_data %>% 
  count(Groups, Region) %>% 
  arrange(desc(n)) %>% 
  arrange(desc(n))

# Counts per property and group
main_data %>% 
  count(property, Groups) %>% 
  arrange(desc(n))
```

**Recreate the graphs that was shown in the intake meeting**

```{r}
# Create summmary (mean +- SE) by group, region, and distance
summary_df <- main_data %>%
  group_by(Groups, Region, property, distance) %>%
  summarise(
    mean_val = mean(OpticalProperty, na.rm = TRUE),
    sd_val = sd(OpticalProperty, na.rm = TRUE),
    n = n(),
    se = sd_val / sqrt(n),
    .groups = "drop"
  )
# Standarize Region Names
summary_df <- summary_df %>%
  mutate(
    Region = case_when(
      is.na(Region) ~ "occipital",
      TRUE ~ as.character(Region)
    ),
    Region = factor(Region, levels = c("front", "occipital"))
  )


# Define plot functions 
plot_property <- function(df, region_filter, property_label) {
  df %>%
    filter(property == property_label, Region %in% region_filter) %>%
    ggplot(aes(x = distance, y = mean_val, color = Groups)) +
    geom_point(size = 2) +  # keep dots
    geom_errorbar(aes(ymin = mean_val - se, ymax = mean_val + se), width = 10) +
    # optional smooth trend line (remove if you want only dots + bars)
    # geom_smooth(method = "loess", se = FALSE, linetype = "dashed", alpha = 0.4) +
    scale_color_manual(values = c("black", "red")) +
    theme_minimal(base_size = 12) +
    labs(
      title = paste(paste(region_filter, collapse = " & "), property_label, "vs. Distance"),
      x = "Distance (µm)",
      y = property_label
    )
}



# Combined (all regions)
combined_summary <- summary_df %>%
  group_by(Groups, distance, property) %>%
  summarise(
    mean_val = mean(mean_val, na.rm = TRUE),
    se = sqrt(sum(se^2, na.rm = TRUE)) / 2,  # conservative SE estimate
    .groups = "drop"
  ) %>%
  mutate(Region = "combined")


summary_df_balanced <- bind_rows(summary_df, combined_summary)


p_combined_scatt <- plot_property(summary_df_balanced, "combined", "scattering")
p_combined_ret   <- plot_property(summary_df_balanced, "combined", "retardance")
p_combined_ori   <- plot_property(summary_df_balanced, "combined", "orientation")

p_front_scatt <- plot_property(summary_df_balanced, "front", "scattering")
p_front_ret   <- plot_property(summary_df_balanced, "front", "retardance")
p_front_ori   <- plot_property(summary_df_balanced, "front", "orientation")

p_occ_scatt <- plot_property(summary_df_balanced, "occipital", "scattering")
p_occ_ret   <- plot_property(summary_df_balanced, "occipital", "retardance")
p_occ_ori   <- plot_property(summary_df_balanced, "occipital", "orientation")

library(patchwork)
top_row <- p_combined_scatt + p_combined_ret + p_combined_ori
mid_row <- p_front_scatt + p_front_ret + p_front_ori
bottom_row <- p_occ_scatt + p_occ_ret + p_occ_ori

final_plot <- top_row / mid_row / bottom_row +
  plot_annotation(title = "Optical Properties vs Distance (Mean ± SE)")

final_plot
```

ssdsd

```{r}
set.seed(1234)
main_data <- main_data %>%
  mutate(
    Groups = factor(Groups),             # control / experimental
    subID = factor(subID),
    distance = as.numeric(distance),
    OpticalProperty = as.numeric(OpticalProperty),
    property = factor(property, levels = c("scattering", "retardance", "orientation")),
    Region = tolower(as.character(Region))
  )

# Replace NA or blank with occipital, and recode synonyms properly
main_data <- main_data %>%
  mutate(
    Region = case_when(
      is.na(Region) ~ "occipital",
      Region %in% c("", "na") ~ "occipital",
      Region %in% c("front", "frontal") ~ "front",
      Region %in% c("occ", "occipital") ~ "occipital",
      TRUE ~ Region
    ),
    Region = factor(Region, levels = c("front", "occipital"))
  )

# Normalize Region factor to two levels: front and occipital
main_data <- main_data %>% mutate(Region = factor(ifelse(grepl("front", tolower(Region)), "front", "occipital"),
                                        levels = c("front","occipital")))

block_df <- main_data %>%
  group_by(subID, Region, Groups, property, distance) %>%
  summarise(mean_val = mean(OpticalProperty, na.rm = TRUE),
            n_obs = n(),
            .groups = "drop")

# Export basic counts for EDA
counts_table <- main_data %>%
  group_by(property, Region, Groups) %>%
  summarise(n_total = n(), n_blocks = n_distinct(subID), .groups = "drop")


```

dd

```{r}
# 4. Global LMM (distance continuous) per property
props <- unique(block_df$property)
global_results <- list()

for(prop in props){
  datp <- block_df %>% filter(property == prop)
  datp <- datp %>% mutate(dist_c = distance - mean(distance, na.rm = TRUE))
  
  # Need enough subjects to estimate random effect
  if(n_distinct(datp$subID) < 4){
    global_results[[as.character(prop)]] <- tibble(property = prop, model = NA, note = "too few subjects")
    next
  }
  
  modg <- tryCatch(lmer(mean_val ~ Groups * dist_c + (1 | subID), data = datp, REML = TRUE),
                   error = function(e) NULL)
  
  if(is.null(modg)){
    global_results[[as.character(prop)]] <- tibble(property = prop, model = "lmer_failed", note = NA)
  } else {
    # Save summary and ANOVA to file
    sm <- summary(modg)
    an <- anova(modg)
    sink(file.path("~/Documents/MA 675/Consulting-Project-EPVs", paste0("global_lmm_summary_", prop, ".txt")))
    print(sm)
    print(an)
    sink()
    
    # Extract p-values from ANOVA
    p_group <- if("Groups" %in% rownames(an)) an["Groups", "Pr(>F)"] else NA
    p_inter <- if("Groups:dist_c" %in% rownames(an)) an["Groups:dist_c", "Pr(>F)"] else NA
    
    # Save results to the list
    global_results[[as.character(prop)]] <- tibble(
      property = prop,
      model = "lmer",
      p_group = p_group,
      p_interaction = p_inter,
      note = NA
    )
  }
}

# Combine into a single dataframe
global_results_df <- bind_rows(global_results)

summary(modg)
```

```{r}
# Diagnostics for global LMM (example: for scattering)

diagnostic_plot_fn <- function(mod, label) {
  # Residuals vs Fitted plot
  dfres <- data.frame(fitted = fitted(mod), resid = resid(mod))
  
  p1 <- ggplot(dfres, aes(x = fitted, y = resid)) +
    geom_point(alpha = 0.6) +
    geom_smooth(se = FALSE, method = "loess", color = "blue") +
    geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
    labs(
      title = paste0("Residuals vs Fitted: ", label),
      x = "Fitted values",
      y = "Residuals"
    ) +
    theme_minimal(base_size = 13)
  
  print(p1)  # Display plot interactively
  
  # QQ plot (normality of residuals)
  qq_df <- data.frame(sample = resid(mod))
  p2 <- ggplot(qq_df, aes(sample = sample)) +
    stat_qq(alpha = 0.6) +
    stat_qq_line(color = "red") +
    labs(
      title = paste0("QQ Plot: ", label),
      x = "Theoretical Quantiles",
      y = "Sample Quantiles"
    ) +
    theme_minimal(base_size = 13)
  
  print(p2)  # Display QQ plot interactively
}

# Run diagnostics for each property model if available
for (prop in props) {
  message("Showing diagnostics for: ", prop)
  
  datp <- block_df %>%
    filter(property == prop) %>%
    mutate(dist_c = distance - mean(distance, na.rm = TRUE))
  
  modg <- tryCatch(
    lmer(mean_val ~ Groups * dist_c + (1 | subID), data = datp, REML = TRUE),
    error = function(e) NULL
  )
  
  if (!is.null(modg)) {
    diagnostic_plot_fn(modg, paste0("global_", prop))
  } else {
    message("Model failed for: ", prop)
  }
}
```

## Begin SWP Relationship Analysis

A Generalized Additive Model (GAM) is a type of statistical model that allows the relationship between a predictor and an outcome to be non-linear, instead of forcing it to be a straight line.

In a normal linear regression, we assume:

-   Every unit increase in X changes the outcome by the same amount.

-   The relationship is assumed to be a straight line.

But biological processes often aren’t linear — especially tissue changes in disease.

A GAM replaces the straight line with a smooth curve:

We used a Generalized Additive Model because we expected the relationship between size-weighted proximity (SWP) and the optical properties to be non-linear.\

A GAM allows us to model this relationship flexibly, without forcing it into a straight line or predefined curve.\

This lets the data determine the true shape of how tissue optical properties change as proximity to EPVS increases, while still adjusting for differences between brain regions.

```{r}
file <- "op_vs_swp_16-Oct-2025.xlsx"

sheets <- excel_sheets(file)

swp <- map_dfr(sheets, function(s) {
  read_excel(file, sheet = s) %>%
    rename(log_swp = 1, optical_value = 2) %>%  # rename first two columns consistently
    mutate(sheet_name = s)
})

# Label property + region
swp <- swp %>%
  mutate(
    property = case_when(
      str_detect(sheet_name, "mus") ~ "scattering",
      str_detect(sheet_name, "ret") ~ "retardance"
    ),
    region = case_when(
      str_detect(sheet_name, "front") ~ "frontal",
      str_detect(sheet_name, "occip") ~ "occipital",
      TRUE ~ "combined"
    )
  )

glimpse(swp)
table(swp$property, swp$region)

ggplot(swp, aes(x = log_swp, y = optical_value, color = region)) +
  geom_point(alpha = 0.15) +
  geom_smooth(method = "loess", se = FALSE) +
  facet_wrap(~ property, scales = "free_y") +
  theme_minimal() +
  labs(title = "Optical Properties vs log(SWP)", y = "Optical Value", x = "log(SWP)")
```

```{r}
gam_scatter <- gam(optical_value ~ s(log_swp, k = 6) + region,
                   data = filter(swp, property == "scattering"))

gam_retard <- gam(optical_value ~ s(log_swp, k = 6) + region,
                  data = filter(swp, property == "retardance"))

par(mfrow=c(1,2))
plot(gam_scatter, shade = TRUE, main = "Scattering vs SWP")
plot(gam_retard, shade = TRUE, main = "Retardance vs SWP")

```

We modeled scattering and retardance as smooth functions of SWP and included region as a fixed effect.\
In both cases, the smooth term was highly significant, confirming a non-linear relationship between SWP and tissue optical properties. Scattering increases and then decreases as SWP increases, consistent with an early increase in extracellular tissue density followed by late-stage tissue degradation. Retardance decreases and then increases, which suggests initial myelin breakdown, followed by fiber compression or re-packing in more advanced disease. Additionally, both scattering and retardance are higher in the occipital region than in the frontal region, consistent with the known pattern of CAA-related white matter vulnerability. The models is a good fit with the adjusted r-squred value (0.74 and 0.76)

I visualized the relationship between EPVS Size-Weighted Proximity (SWP) and optical properties.\

Both scattering and retardance show non-linear dependence on SWP, so linear models are not appropriate.\

A GAM model captures the shape of the curve, which aligns with the biological interpretation:

-   Scattering increases at moderate SWP, likely due to increased cellular density or ECM changes — then drops at high SWP, consistent with late-stage tissue breakdown.

-   Retardance decreases initially, due to myelin degeneration — then rises again, suggesting myelin fiber compression in late disease progression.

-   Regional effects (frontal vs occipital) will be tested next, but occipital is expected to show stronger pathology based on previous findings.

Below is a more advanced visualization

```{r}
p1 <- ggplot(swp, aes(x = log_swp, y = optical_value, color = region)) +
  geom_point(alpha = 0.12, size = 0.7) +
  geom_smooth(method = "loess", se = FALSE, linewidth = 1.2) +
  facet_wrap(~ property, scales = "free_y") +
  scale_color_manual(values = c("combined"="#888888", "frontal"="#1f78b4", "occipital"="#e31a1c")) +
  theme_minimal(base_size = 14) +
  labs(title = "Optical Properties vs log(SWP)",
       x = "log(SWP)",
       y = "Optical Property Value",
       color = "Region")
p1

```

```{r}

# Predict for smooth plotting
newdata <- swp %>%
  group_by(region) %>%
  reframe(log_swp = seq(min(log_swp), max(log_swp), length.out = 200), .groups="drop")

newdata$scatter_pred <- predict(gam_scatter, newdata)
newdata$ret_pred <- predict(gam_retard, newdata)
p2 <- ggplot(newdata, aes(x = log_swp, color = region)) +
  geom_line(aes(y = scatter_pred), linewidth = 1.4) +
  geom_line(aes(y = ret_pred), linetype="dashed", linewidth=1.4) +
  scale_color_manual(values = c("combined"="#888888", "frontal"="#1f78b4", "occipital"="#e31a1c")) +
  theme_minimal(base_size = 14) +
  labs(title = "GAM Smooths: Scattering (solid) & Retardance (dashed)",
       x = "log(SWP)",
       y = "Optical Property Value",
       color = "Region")

p2
```
